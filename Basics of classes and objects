Cуть принципа подстановки Лисков: поведение классов-наследников классов не должно противоречить поведению, заданному базовым классом.
Предположим, что у нас есть класс Rectangle, который описывает прямоугольник:

@NoArgsConstructor
@Data
public class Rectangle {
    protected int width;
    protected int height;

    public int calculateArea() {
        return width * height;
    }
}

У этого класса есть поля width и height, которые задают ширину и высоту прямоугольника, а также метод calculateArea(), который рассчитывает площадь прямоугольника, как произведение его ширины на высоту.
Теперь представим, что мы создаём новый класс Square для описания квадрата. И мы захотели сделать его наследником нашего класса Rectangle:

@NoArgsConstructor
public class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        this.width = width;
        this.height = width;
    }

    @Override
    public void setHeight(int height) {
        this.height = height;
        this.width = height;
    }
}

Через подобное наследование мы хотим представить квадрат как частный случай прямоугольника, у которого равны длины обеих сторон.
Можно увидеть, что при помощи аннотации Lombok @NoArgsConstructor, который есть и в классе-родителе Rectangle, и в классе-наследнике Square, мы указываем, что у этих классов будет только конструктор без параметров.
Соответственно, для установки ширины и высоты прямоугольника и квадрата нам придётся использовать доступные методы setWidth(int width) или setHeight(int height).
Но здесь же мы видим, что в переопределённых методах класса Square мы одновременно переписываем оба поля! Не важно, какой именно сеттер будет вызван - обе стороны будут установлены в одно и то же значение.

При проведении тестов можно заметить, что проверка для квадрата никогда не выполнится, поскольку нарушен принцип подстановки Барбары Лисков. Например:

class FiguresTest {
    @Test
    void testFiguresArea() {
        Rectangle r = new Rectangle(); // прямоугольник
        r.setWidth(2);
        r.setHeight(5);
        assertEquals(10, r.calculateArea());

        r = new Square(); //квадрат
        r.setWidth(2);
        r.setHeight(5);

        // Проверка ниже никогда не выполнится.
        // Площадь квадрата будет равна 25, т.к. последним сеттером устанавливается сторона квадрата, равная 5.

        assertEquals(10, r.calculateArea()); // ошибка!
    }
}

Для решения проблемы Введём новый интерфейс Figure для описания какой-то фигуры, и пусть он будет иметь единственный метод calculateArea() для вычисления площади этой фигуры:

public interface Figure {
    int calculateArea();
}

Для прямоугольника:

@AllArgsConstructor
@Data
public class Rectangle implements Figure {

    protected int width;
    protected int height;

    @Override
    public int calculateArea() {
        return width * height;
    }
}

Теперь класс проаннотирован через @AllArgsConstructor и @Data, а значит, у него будет конструктор, принимающий ширину и высоту прямоугольника, а также геттеры и сеттеры для установки ширины и высоты.
Класс также реализует новый интерфейс Figure и его метод calculateArea(), где происходит вычисление площади нашей фигуры (прямоугольника).
Для квадрата:

@AllArgsConstructor
@Data
public class Square implements Figure {
    protected int side;

    @Override
    public int calculateArea() {
        return side * side;
    }
}

Как видим, у него будет параметризованный конструктор, принимающий длину стороны квадрата, 1 геттер для получения стороны квадрата и 1 сеттер - для установки стороны квадрата.
Этот класс также реализует интерфейс Figure и его метод для расчёта площади фигуры (квадрата).
Заметьте, что мы избавились от наследования - теперь класс Square не является потомком класса Rectangle, это два независимых класса. Но они оба реализуют интерфейс Figure, который в примере умеет считать площадь фигуры.

Теперь же принцип подстановки Барбары Лисков не нарушен и тесты будут корректно работать. Между классами Square и Rectangle отсутствует наследование, каждый класс является независимым. При этом оба класса реализуют интерфейс, способный вычислять площадь фигуры.

